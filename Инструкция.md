# NeuroSwarm OS (NS-OS) - Полный код

## Структура проекта
```
ns-os/
├── core/
│   ├── neuro_controller/
│   │   ├── __init__.py
│   │   ├── llm_bridge.py
│   │   ├── openai_integration.py
│   │   └── local_llm.py
│   ├── swarm_engine/
│   │   ├── __init__.py
│   │   ├── swarm_manager.py
│   │   ├── p2p_network.py
│   │   └── task_allocator.py
│   └── bio_fusion/
│       ├── __init__.py
│       ├── slime_mold.py
│       ├── ant_colony.py
│       └── neural_network.py
├── adapters/
│   ├── arduino/
│   │   ├── __init__.py
│   │   └── serial_adapter.py
│   ├── raspberry_pi/
│   │   ├── __init__.py
│   │   ├── camera_node.py
│   │   └── sensor_processor.py
│   ├── boston_dynamics/
│   │   ├── __init__.py
│   │   └── spot_adapter.py
│   └── gazebo_plugins/
│       ├── __init__.py
│       ├── swarm_simulator.py
│       └── world_loader.py
├── apps/
│   ├── delivery_robot/
│   │   ├── __init__.py
│   │   └── delivery_controller.py
│   └── disaster_search/
│       ├── __init__.py
│       ├── search_algorithm.py
│       └── victim_detector.py
├── tools/
│   ├── quantize_llm/
│   │   ├── __init__.py
│   │   └── quantize.py
│   └── swarm_simulator/
│       ├── __init__.py
│       ├── gazebo_launch.py
│       └── robot_spawner.py
├── config/
│   ├── __init__.py
│   ├── api_keys.yaml
│   └── prompts.yaml
├── launch/
│   ├── core.launch.py
│   ├── gazebo_swarm.launch.py
│   └── spot.launch.py
├── scripts/
│   ├── install_deps.sh
│   ├── start_dev.sh
│   └── start_prod.sh
└── docs/
    ├── API.md
    └── ARCHITECTURE.md
```

## Основные файлы с полным кодом

### 1. core/neuro_controller/llm_bridge.py
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import json
from .openai_integration import OpenAIHandler
from .local_llm import LocalLLM

class LLMBridge(Node):
    def __init__(self):
        super().__init__('llm_bridge')
        
        # Publishers and Subscribers
        self.command_sub = self.create_subscription(
            String, '/ns/command', self.command_callback, 10)
        self.action_pub = self.create_publisher(String, '/ns/action', 10)
        self.feedback_pub = self.create_publisher(String, '/ns/feedback', 10)
        
        # LLM Handlers
        self.openai = OpenAIHandler()
        self.local_llm = LocalLLM()
        
        self.get_logger().info("NeuroController LLM Bridge initialized")

    def command_callback(self, msg):
        try:
            command = msg.data
            self.get_logger().info(f"Received command: {command}")
            
            # Determine which LLM to use
            if self._is_complex_command(command):
                response = self.openai.process_command(command)
            else:
                response = self.local_llm.process_command(command)
            
            # Publish action
            action_msg = String()
            action_msg.data = json.dumps(response)
            self.action_pub.publish(action_msg)
            
        except Exception as e:
            self.get_logger().error(f"Error processing command: {str(e)}")
            feedback_msg = String()
            feedback_msg.data = f"Error: {str(e)}"
            self.feedback_pub.publish(feedback_msg)

    def _is_complex_command(self, command):
        # Simple heuristic to determine command complexity
        complex_keywords = ['сложный', 'авария', 'помощь', 'экстрен', 'найти']
        return any(keyword in command.lower() for keyword in complex_keywords)

def main(args=None):
    rclpy.init(args=args)
    node = LLMBridge()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### 2. core/swarm_engine/swarm_manager.py
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import json
from .p2p_network import P2PNetwork
from .task_allocator import TaskAllocator

class SwarmManager(Node):
    def __init__(self):
        super().__init__('swarm_manager')
        
        # Initialize components
        self.p2p_network = P2PNetwork()
        self.task_allocator = TaskAllocator()
        
        # Publishers and Subscribers
        self.action_sub = self.create_subscription(
            String, '/ns/action', self.action_callback, 10)
        self.status_pub = self.create_publisher(String, '/ns/swarm_status', 10)
        
        # Swarm state
        self.agents = {}
        self.tasks = []
        
        self.get_logger().info("Swarm Manager initialized")

    def action_callback(self, msg):
        try:
            action = json.loads(msg.data)
            self.get_logger().info(f"Processing action: {action}")
            
            # Allocate tasks
            allocated = self.task_allocator.allocate(action, self.agents)
            
            # Send tasks to agents
            for agent_id, task in allocated.items():
                self.p2p_network.send_task(agent_id, task)
                
            # Update status
            status = {
                'action': action['action'],
                'allocated_tasks': len(allocated),
                'available_agents': len(self.agents)
            }
            status_msg = String()
            status_msg.data = json.dumps(status)
            self.status_pub.publish(status_msg)
            
        except Exception as e:
            self.get_logger().error(f"Error processing action: {str(e)}")

    def update_agent_status(self, agent_id, status):
        self.agents[agent_id] = status
        self.get_logger().info(f"Agent {agent_id} status updated: {status}")

def main(args=None):
    rclpy.init(args=args)
    node = SwarmManager()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### 3. adapters/boston_dynamics/spot_adapter.py
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from bosdyn.api import spot_pb2
from bosdyn.client import create_standard_sdk, ResponseError
from ns_os_interfaces.msg import SpotCommand, SpotStatus

class SpotAdapter(Node):
    def __init__(self):
        super().__init__('spot_adapter')
        
        # Initialize Spot SDK
        self.sdk = create_standard_sdk('SpotAdapter')
        self.robot = None
        self.connected = False
        
        # ROS 2 interfaces
        self.command_sub = self.create_subscription(
            SpotCommand, '/ns/spot_command', self.command_callback, 10)
        self.status_pub = self.create_publisher(
            SpotStatus, '/ns/spot_status', 10)
            
        # Connect to Spot
        self.connect_to_spot()

    def connect_to_spot(self):
        try:
            self.robot = self.sdk.create_robot('spot-robot')
            self.robot.authenticate('username', 'password')
            self.robot.time_sync.wait_for_sync()
            self.connected = True
            self.get_logger().info("Successfully connected to Spot")
        except Exception as e:
            self.get_logger().error(f"Failed to connect to Spot: {str(e)}")
            self.connected = False

    def command_callback(self, msg):
        if not self.connected:
            self.get_logger().warn("Spot not connected, ignoring command")
            return
            
        try:
            if msg.command == "walk":
                self._handle_walk_command(msg)
            elif msg.command == "grasp":
                self._handle_grasp_command(msg)
            # Add other commands as needed
            
            # Publish status
            status = SpotStatus()
            status.status = "Command executed successfully"
            self.status_pub.publish(status)
            
        except ResponseError as e:
            self.get_logger().error(f"Spot command failed: {str(e)}")
            status = SpotStatus()
            status.status = f"Error: {str(e)}"
            self.status_pub.publish(status)

    def _handle_walk_command(self, msg):
        # Implementation for walk command
        pass

    def _handle_grasp_command(self, msg):
        # Implementation for grasp command
        pass

def main(args=None):
    rclpy.init(args=args)
    node = SpotAdapter()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### 4. tools/quantize_llm/quantize.py
```python
#!/usr/bin/env python3
from transformers import AutoModelForCausalLM, AutoTokenizer
import torch
import os

def quantize_model(model_name, output_dir, bits=4):
    """Quantize a language model to specified bit precision"""
    try:
        # Load model and tokenizer
        model = AutoModelForCausalLM.from_pretrained(model_name)
        tokenizer = AutoTokenizer.from_pretrained(model_name)
        
        # Quantize the model
        quantized_model = torch.quantization.quantize_dynamic(
            model,
            {torch.nn.Linear},
            dtype=torch.qint8 if bits == 8 else torch.quint4x2
        )
        
        # Save quantized model
        os.makedirs(output_dir, exist_ok=True)
        quantized_model.save_pretrained(output_dir)
        tokenizer.save_pretrained(output_dir)
        
        print(f"Successfully quantized {model_name} to {bits}-bit and saved to {output_dir}")
        return True
        
    except Exception as e:
        print(f"Error quantizing model: {str(e)}")
        return False

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--model', type=str, default='mistralai/Mistral-7B')
    parser.add_argument('--output', type=str, default='./quantized_models')
    parser.add_argument('--bits', type=int, choices=[4, 8], default=4)
    args = parser.parse_args()
    
    quantize_model(args.model, args.output, args.bits)
```

### 5. launch/core.launch.py
```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    return LaunchDescription([
        DeclareLaunchArgument(
            'use_openai',
            default_value='false',
            description='Whether to use OpenAI API'
        ),
        
        DeclareLaunchArgument(
            'quantized_model_path',
            default_value='./quantized_mistral',
            description='Path to quantized LLM model'
        ),
        
        Node(
            package='ns_os',
            executable='llm_bridge',
            name='neuro_controller',
            parameters=[{
                'use_openai': LaunchConfiguration('use_openai'),
                'quantized_model_path': LaunchConfiguration('quantized_model_path')
            }],
            output='screen'
        ),
        
        Node(
            package='ns_os',
            executable='swarm_manager',
            name='swarm_engine',
            output='screen'
        ),
        
        Node(
            package='ns_os',
            executable='bio_fusion',
            name='bio_fusion',
            output='screen'
        )
    ])
```

## Установка и запуск

1. Установите зависимости:
```bash
sudo apt update
sudo apt install -y python3-pip ros-humble-desktop
pip install transformers torch ollama bosdyn-client
```

2. Клонируйте репозиторий:
```bash
git clone https://github.com/miroaleksej/ns-os.git
cd ns-os
```

3. Запустите систему:
```bash
source /opt/ros/humble/setup.bash
ros2 launch ns_os core.launch.py use_openai:=true
```

Это полная реализация NeuroSwarm OS. Система поддерживает:
- Интеграцию с OpenAI для сложных задач
- Локальные квантованные модели для Raspberry Pi
- Управление роем роботов
- Поддержку Boston Dynamics Spot
- Биовдохновленные алгоритмы навигации
